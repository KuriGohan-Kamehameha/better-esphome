substitutions:
  device_name: atom-lite
  friendly_name: Atom Lite

  # Atom Lite pin map (M5Stack official docs)
  pin_ir_tx: GPIO12
  pin_rgb: GPIO27
  pin_button: GPIO39
  pin_i2c_scl: GPIO21
  pin_i2c_sda: GPIO25

esphome:
  name: ${device_name}
  friendly_name: ${friendly_name}
  # NOTE: api action responses (api.respond / supports_response) are in 2025.12.0+
  min_version: 2025.12.0
  project:
    # Must be exactly "author.project" (single dot)
    name: "m5stack.atom_lite_ir_blaster"
    version: "2.0.0"
  # Defensive: avoids some ESP32-IDF BLE reboot-loop edge cases on certain modules
  platformio_options:
    board_build.flash_mode: dio

esp32:
  board: m5stack-atom
  framework:
    type: esp-idf

logger:
  level: INFO
  baud_rate: 0

# IR serialization + bounded queue (prevents overlapping sends and avoids dropped calls)
globals:
  - id: ir_busy
    type: bool
    restore_value: no
    initial_value: 'false'

  # FIFO items:
  #   NEC:    "N|<address>|<command>|<repeats>"
  #   PRONTO: "P|<repeats>|<data>"
  - id: ir_queue
    type: 'std::vector<std::string>'
    restore_value: no

  # Parsed current item (worker uses these)
  - id: ir_task_proto
    type: uint8_t
    restore_value: no
    initial_value: '0'   # 0=none, 1=NEC, 2=PRONTO
  - id: ir_task_addr
    type: uint16_t
    restore_value: no
    initial_value: '0'
  - id: ir_task_cmd
    type: uint16_t
    restore_value: no
    initial_value: '0'
  - id: ir_task_repeats
    type: uint8_t
    restore_value: no
    initial_value: '1'
  - id: ir_task_pronto
    type: std::string
    restore_value: no
    initial_value: '""'

api:
  encryption:
    key: "zrAdXmH0/NW3OXKp8N0jft8woveyAPkpyi5zCBzJuak="
  actions:
    # Home Assistant action: esphome.atom_lite_ir_send_nec
    # Behavior: returns success when ACCEPTED/QUEUED (not when finished transmitting)
    - action: ir_send_nec
      supports_response: status
      variables:
        address: int
        command: int
        send_times: int
      then:
        - if:
            condition:
              lambda: |-
                const bool addr_ok = (address >= 0) && (address <= 0xFFFF);
                const bool cmd_ok  = (command >= 0) && (command <= 0xFFFF);
                return addr_ok && cmd_ok;
            then:
              - if:
                  condition:
                    lambda: |-
                      constexpr size_t IR_QUEUE_MAX = 20;
                      return id(ir_queue).size() < IR_QUEUE_MAX;
                  then:
                    - lambda: |-
                        int rep = send_times;
                        if (rep < 1) rep = 1;
                        if (rep > 20) rep = 20;

                        char task[64];
                        snprintf(task, sizeof(task), "N|%d|%d|%d", address, command, rep);
                        id(ir_queue).push_back(task);

                        char msg[140];
                        snprintf(msg, sizeof(msg), "QUEUED NEC addr=0x%04X cmd=0x%04X rep=%d q=%u",
                                 (uint16_t) address, (uint16_t) command, rep, (unsigned) id(ir_queue).size());
                        id(atom_ir_last_tx).publish_state(msg);
                        id(atom_ir_last_error).publish_state("");
                        ESP_LOGI("ir", "%s", msg);
                    - script.execute: ir_process_queue
                    - api.respond:
                        success: true
                  else:
                    - logger.log:
                        level: WARN
                        format: "ir_send_nec: queue full (%u/20)"
                        args: [ '(unsigned) id(ir_queue).size()' ]
                    - lambda: |-
                        id(atom_ir_last_error).publish_state("IR queue full");
                    - api.respond:
                        success: false
                        error_message: "IR queue full"
            else:
              - logger.log:
                  level: ERROR
                  format: "ir_send_nec: invalid args address=%d command=%d"
                  args: [ 'address', 'command' ]
              - api.respond:
                  success: false
                  error_message: !lambda |-
                    char buf[96];
                    snprintf(buf, sizeof(buf), "invalid args address=%d command=%d", address, command);
                    return std::string(buf);

    # Home Assistant action: esphome.atom_lite_ir_send_pronto
    # Behavior: returns success when ACCEPTED/QUEUED (not when finished transmitting)
    - action: ir_send_pronto
      supports_response: status
      variables:
        data: string
        send_times: int
      then:
        - if:
            condition:
              lambda: |-
                return (!data.empty() && data.size() <= 1024);
            then:
              - if:
                  condition:
                    lambda: |-
                      constexpr size_t IR_QUEUE_MAX = 20;
                      return id(ir_queue).size() < IR_QUEUE_MAX;
                  then:
                    - lambda: |-
                        int rep = send_times;
                        if (rep < 1) rep = 1;
                        if (rep > 10) rep = 10;

                        // Accept as-is; worker will normalize whitespace defensively.
                        std::string task = "P|" + std::to_string(rep) + "|" + data;
                        id(ir_queue).push_back(task);

                        char msg[140];
                        snprintf(msg, sizeof(msg), "QUEUED PRONTO len=%u rep=%d q=%u",
                                 (unsigned) data.size(), rep, (unsigned) id(ir_queue).size());
                        id(atom_ir_last_tx).publish_state(msg);
                        id(atom_ir_last_error).publish_state("");
                        ESP_LOGI("ir", "%s", msg);
                    - script.execute: ir_process_queue
                    - api.respond:
                        success: true
                  else:
                    - logger.log:
                        level: WARN
                        format: "ir_send_pronto: queue full (%u/20)"
                        args: [ '(unsigned) id(ir_queue).size()' ]
                    - lambda: |-
                        id(atom_ir_last_error).publish_state("IR queue full");
                    - api.respond:
                        success: false
                        error_message: "IR queue full"
            else:
              - logger.log:
                  level: ERROR
                  format: "ir_send_pronto: invalid args data_len=%u"
                  args: [ '(unsigned) data.size()' ]
              - api.respond:
                  success: false
                  error_message: !lambda |-
                    char buf[96];
                    snprintf(buf, sizeof(buf), "invalid args data_len=%u", (unsigned) data.size());
                    return std::string(buf);

ota:
  - platform: esphome
    password: "946e8243f5520c12bd0a32651e24a86e"

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  power_save_mode: none

safe_mode:

# BLE Proxy
esp32_ble_tracker:

bluetooth_proxy:
  active: true
  cache_services: true
  connection_slots: 3

i2c:
  sda: ${pin_i2c_sda}
  scl: ${pin_i2c_scl}
  scan: true
  frequency: 400kHz

# -------------------------
# IR UI (Home Assistant)
# -------------------------
text:
  - platform: template
    name: "Atom Lite IR NEC Address"
    id: atom_ir_nec_address
    mode: text
    optimistic: true
    restore_value: true
    min_length: 1
    max_length: 10
    initial_value: "0x0000"
    on_value:
      then:
        - lambda: |-
            // Trim whitespace for copy/paste friendliness
            std::string s = x;
            auto trim = [](std::string &v) {
              while (!v.empty() && (v.front() == ' ' || v.front() == '\t' || v.front() == '\r' || v.front() == '\n')) v.erase(v.begin());
              while (!v.empty() && (v.back()  == ' ' || v.back()  == '\t' || v.back()  == '\r' || v.back()  == '\n')) v.pop_back();
            };
            std::string t = s;
            trim(t);
            if (t != s) {
              auto call = id(atom_ir_nec_address).make_call();
              call.set_value(t);
              call.perform();
            }

  - platform: template
    name: "Atom Lite IR NEC Command"
    id: atom_ir_nec_command
    mode: text
    optimistic: true
    restore_value: true
    min_length: 1
    max_length: 10
    initial_value: "0x0000"
    on_value:
      then:
        - lambda: |-
            std::string s = x;
            auto trim = [](std::string &v) {
              while (!v.empty() && (v.front() == ' ' || v.front() == '\t' || v.front() == '\r' || v.front() == '\n')) v.erase(v.begin());
              while (!v.empty() && (v.back()  == ' ' || v.back()  == '\t' || v.back()  == '\r' || v.back()  == '\n')) v.pop_back();
            };
            std::string t = s;
            trim(t);
            if (t != s) {
              auto call = id(atom_ir_nec_command).make_call();
              call.set_value(t);
              call.perform();
            }

  - platform: template
    name: "Atom Lite IR Pronto Data"
    id: atom_ir_pronto_data
    mode: text
    optimistic: true
    restore_value: true
    min_length: 255
    max_length: 255
    initial_value: ""
    on_value:
      then:
        - lambda: |-
            // Normalize whitespace (newlines/tabs -> spaces, collapse runs, trim)
            std::string raw = x;
            std::string cleaned;
            cleaned.reserve(raw.size());
            bool last_space = true;

            for (char c : raw) {
              if (c == '\r' || c == '\n' || c == '\t') c = ' ';
              if (c == ' ') {
                if (!last_space) cleaned.push_back(' ');
                last_space = true;
              } else {
                cleaned.push_back(c);
                last_space = false;
              }
            }
            while (!cleaned.empty() && cleaned.back() == ' ') cleaned.pop_back();
            size_t start = 0;
            while (start < cleaned.size() && cleaned[start] == ' ') start++;
            if (start > 0) cleaned.erase(0, start);

            if (cleaned != raw) {
              auto call = id(atom_ir_pronto_data).make_call();
              call.set_value(cleaned);
              call.perform();
            }

number:
  - platform: template
    name: "Atom Lite IR NEC Repeats"
    id: atom_ir_nec_repeats
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 1
    min_value: 1
    max_value: 20
    step: 1
    mode: box

  - platform: template
    name: "Atom Lite IR Pronto Repeats"
    id: atom_ir_pronto_repeats
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 1
    min_value: 1
    max_value: 10
    step: 1
    mode: box

  - platform: template
    name: "Atom Lite IR Inter-Command Gap"
    id: atom_ir_gap_ms
    entity_category: config
    optimistic: true
    restore_value: true
    initial_value: 100
    min_value: 0
    max_value: 1000
    step: 10
    mode: box
    unit_of_measurement: "ms"

script:
  - id: ir_process_queue
    mode: single
    then:
      - while:
          condition:
            lambda: 'return !id(ir_queue).empty();'
          then:
            # Pop + parse next task into ir_task_*
            - lambda: |-
                std::string task = id(ir_queue).front();
                id(ir_queue).erase(id(ir_queue).begin());

                // Reset parsed task
                id(ir_task_proto) = 0;
                id(ir_task_addr) = 0;
                id(ir_task_cmd) = 0;
                id(ir_task_repeats) = 1;
                id(ir_task_pronto).clear();

                if (task.size() < 3 || task[1] != '|') {
                  char buf[96];
                  snprintf(buf, sizeof(buf), "IR queue item malformed (len=%u)", (unsigned) task.size());
                  id(atom_ir_last_error).publish_state(buf);
                  ESP_LOGE("ir", "%s", buf);
                  return;
                }

                auto parse_u32 = [](const std::string &s, uint32_t minv, uint32_t maxv, uint32_t &out) -> bool {
                  if (s.empty()) return false;
                  if (s[0] == '-') return false;
                  char *end = nullptr;
                  const unsigned long v = strtoul(s.c_str(), &end, 0);  // decimal or 0x-prefixed hex
                  if (end == nullptr || end == s.c_str() || *end != '\0') return false;
                  if (v < minv || v > maxv) return false;
                  out = (uint32_t) v;
                  return true;
                };

                if (task[0] == 'N') {
                  const size_t p1 = task.find('|', 2);
                  const size_t p2 = (p1 == std::string::npos) ? std::string::npos : task.find('|', p1 + 1);
                  if (p1 == std::string::npos || p2 == std::string::npos) {
                    id(atom_ir_last_error).publish_state("IR NEC item malformed");
                    ESP_LOGE("ir", "IR NEC item malformed");
                    return;
                  }

                  const std::string s_addr = task.substr(2, p1 - 2);
                  const std::string s_cmd  = task.substr(p1 + 1, p2 - (p1 + 1));
                  const std::string s_rep  = task.substr(p2 + 1);

                  uint32_t addr=0, cmd=0, rep=0;
                  if (!parse_u32(s_addr, 0, 0xFFFF, addr) ||
                      !parse_u32(s_cmd,  0, 0xFFFF, cmd)  ||
                      !parse_u32(s_rep,  1, 20,     rep)) {
                    char buf[160];
                    snprintf(buf, sizeof(buf), "IR NEC item invalid (addr=%s cmd=%s rep=%s)",
                             s_addr.c_str(), s_cmd.c_str(), s_rep.c_str());
                    id(atom_ir_last_error).publish_state(buf);
                    ESP_LOGE("ir", "%s", buf);
                    return;
                  }

                  id(ir_task_proto) = 1;
                  id(ir_task_addr) = (uint16_t) addr;
                  id(ir_task_cmd) = (uint16_t) cmd;
                  id(ir_task_repeats) = (uint8_t) rep;
                  id(atom_ir_last_error).publish_state("");
                  return;
                }

                if (task[0] == 'P') {
                  const size_t p1 = task.find('|', 2);
                  if (p1 == std::string::npos) {
                    id(atom_ir_last_error).publish_state("IR PRONTO item malformed");
                    ESP_LOGE("ir", "IR PRONTO item malformed");
                    return;
                  }

                  const std::string s_rep = task.substr(2, p1 - 2);
                  const std::string raw   = task.substr(p1 + 1);

                  uint32_t rep=0;
                  if (!parse_u32(s_rep, 1, 10, rep)) {
                    char buf[120];
                    snprintf(buf, sizeof(buf), "IR PRONTO item invalid repeats=%s", s_rep.c_str());
                    id(atom_ir_last_error).publish_state(buf);
                    ESP_LOGE("ir", "%s", buf);
                    return;
                  }

                  // Normalize whitespace + trim (copy/paste friendly)
                  std::string cleaned;
                  cleaned.reserve(raw.size());
                  bool last_space = true;
                  for (char c : raw) {
                    if (c == '\r' || c == '\n' || c == '\t') c = ' ';
                    if (c == ' ') {
                      if (!last_space) cleaned.push_back(' ');
                      last_space = true;
                    } else {
                      cleaned.push_back(c);
                      last_space = false;
                    }
                  }
                  while (!cleaned.empty() && cleaned.back() == ' ') cleaned.pop_back();
                  size_t start = 0;
                  while (start < cleaned.size() && cleaned[start] == ' ') start++;
                  if (start > 0) cleaned.erase(0, start);

                  if (cleaned.empty() || cleaned.size() > 1024) {
                    char buf[120];
                    snprintf(buf, sizeof(buf), "IR PRONTO data invalid len=%u", (unsigned) cleaned.size());
                    id(atom_ir_last_error).publish_state(buf);
                    ESP_LOGE("ir", "%s", buf);
                    return;
                  }

                  id(ir_task_proto) = 2;
                  id(ir_task_repeats) = (uint8_t) rep;
                  id(ir_task_pronto) = cleaned;
                  id(atom_ir_last_error).publish_state("");
                  return;
                }

                {
                  char buf[96];
                  snprintf(buf, sizeof(buf), "IR queue item unknown proto='%c'", task[0]);
                  id(atom_ir_last_error).publish_state(buf);
                  ESP_LOGE("ir", "%s", buf);
                }

            # NEC send path
            - if:
                condition:
                  lambda: 'return id(ir_task_proto) == 1;'
                then:
                  - lambda: |-
                      id(ir_busy) = true;
                      char buf[140];
                      snprintf(buf, sizeof(buf), "TX NEC addr=0x%04X cmd=0x%04X rep=%u q=%u",
                               id(ir_task_addr), id(ir_task_cmd), id(ir_task_repeats),
                               (unsigned) id(ir_queue).size());
                      id(atom_ir_last_tx).publish_state(buf);
                      ESP_LOGI("ir", "%s", buf);
                  - remote_transmitter.transmit_nec:
                      transmitter_id: atom_ir
                      address: !lambda 'return id(ir_task_addr);'
                      command: !lambda 'return id(ir_task_cmd);'
                      repeat:
                        times: !lambda 'return (uint32_t) id(ir_task_repeats);'
                        wait_time: 10ms
                  - wait_until:
                      condition:
                        lambda: 'return !id(ir_busy);'
                      timeout: 10s
                  - if:
                      condition:
                        lambda: 'return id(ir_busy);'
                      then:
                        - lambda: |-
                            id(atom_ir_last_error).publish_state("IR TIMEOUT (NEC) - queue canceled; use Clear Busy only for recovery");
                            ESP_LOGE("ir", "IR TIMEOUT (NEC) - canceling queue");
                            id(ir_queue).clear();
                        - script.stop: ir_process_queue
                      else:
                        - delay: !lambda |-
                            float f = id(atom_ir_gap_ms).state;
                            if (f != f) f = 100.0f;  // NaN guard
                            int ms = (f <= 0.0f) ? 0 : (int) (f + 0.5f);
                            return (uint32_t) ms;
                else:
                  # PRONTO send path
                  - if:
                      condition:
                        lambda: 'return id(ir_task_proto) == 2;'
                      then:
                        - lambda: |-
                            id(ir_busy) = true;
                            char buf[140];
                            snprintf(buf, sizeof(buf), "TX PRONTO len=%u rep=%u q=%u",
                                     (unsigned) id(ir_task_pronto).size(), id(ir_task_repeats),
                                     (unsigned) id(ir_queue).size());
                            id(atom_ir_last_tx).publish_state(buf);
                            ESP_LOGI("ir", "%s", buf);
                        - remote_transmitter.transmit_pronto:
                            transmitter_id: atom_ir
                            data: !lambda 'return id(ir_task_pronto);'
                            repeat:
                              times: !lambda 'return (uint32_t) id(ir_task_repeats);'
                              wait_time: 10ms
                        - wait_until:
                            condition:
                              lambda: 'return !id(ir_busy);'
                            timeout: 30s
                        - if:
                            condition:
                              lambda: 'return id(ir_busy);'
                            then:
                              - lambda: |-
                                  id(atom_ir_last_error).publish_state("IR TIMEOUT (PRONTO) - queue canceled; use Clear Busy only for recovery");
                                  ESP_LOGE("ir", "IR TIMEOUT (PRONTO) - canceling queue");
                                  id(ir_queue).clear();
                              - script.stop: ir_process_queue
                            else:
                              - delay: !lambda |-
                                  float f = id(atom_ir_gap_ms).state;
                                  if (f != f) f = 100.0f;  // NaN guard
                                  int ms = (f <= 0.0f) ? 0 : (int) (f + 0.5f);
                                  return (uint32_t) ms;
                      else:
                        - delay: 1ms

button:
  - platform: restart
    name: "Atom Lite Restart"

  - platform: safe_mode
    name: "Atom Lite Restart (Safe Mode)"

  # One-tap UI send buttons (use the IR UI inputs above)
  - platform: template
    name: "Atom Lite IR Send NEC"
    on_press:
      - lambda: |-
          constexpr size_t IR_QUEUE_MAX = 20;

          auto trim = [](std::string &v) {
            while (!v.empty() && (v.front() == ' ' || v.front() == '\t' || v.front() == '\r' || v.front() == '\n')) v.erase(v.begin());
            while (!v.empty() && (v.back()  == ' ' || v.back()  == '\t' || v.back()  == '\r' || v.back()  == '\n')) v.pop_back();
          };
          auto parse_u32 = [](const std::string &s, uint32_t minv, uint32_t maxv, uint32_t &out) -> bool {
            if (s.empty()) return false;
            if (s[0] == '-') return false;
            char *end = nullptr;
            const unsigned long v = strtoul(s.c_str(), &end, 0);
            if (end == nullptr || end == s.c_str() || *end != '\0') return false;
            if (v < minv || v > maxv) return false;
            out = (uint32_t) v;
            return true;
          };

          std::string s_addr = id(atom_ir_nec_address).state;
          std::string s_cmd  = id(atom_ir_nec_command).state;
          trim(s_addr);
          trim(s_cmd);

          uint32_t addr=0, cmd=0;
          if (!parse_u32(s_addr, 0, 0xFFFF, addr) || !parse_u32(s_cmd, 0, 0xFFFF, cmd)) {
            char buf[160];
            snprintf(buf, sizeof(buf), "NEC input invalid (addr='%s' cmd='%s')", s_addr.c_str(), s_cmd.c_str());
            id(atom_ir_last_error).publish_state(buf);
            ESP_LOGE("ir", "%s", buf);
            return;
          }

          float f_rep = id(atom_ir_nec_repeats).state;
          if (f_rep != f_rep) f_rep = 1.0f;  // NaN guard
          int rep = (int) (f_rep + 0.5f);
          if (rep < 1) rep = 1;
          if (rep > 20) rep = 20;

          if (id(ir_queue).size() >= IR_QUEUE_MAX) {
            id(atom_ir_last_error).publish_state("IR queue full");
            ESP_LOGW("ir", "NEC not queued: queue full (%u/%u)", (unsigned) id(ir_queue).size(), (unsigned) IR_QUEUE_MAX);
            return;
          }

          char task[64];
          snprintf(task, sizeof(task), "N|%u|%u|%d", (unsigned) addr, (unsigned) cmd, rep);
          id(ir_queue).push_back(task);

          char msg[140];
          snprintf(msg, sizeof(msg), "QUEUED NEC addr=0x%04X cmd=0x%04X rep=%d q=%u",
                   (uint16_t) addr, (uint16_t) cmd, rep, (unsigned) id(ir_queue).size());
          id(atom_ir_last_tx).publish_state(msg);
          id(atom_ir_last_error).publish_state("");
          ESP_LOGI("ir", "%s", msg);
      - script.execute: ir_process_queue

  - platform: template
    name: "Atom Lite IR Send Pronto"
    on_press:
      - lambda: |-
          constexpr size_t IR_QUEUE_MAX = 20;

          std::string raw = id(atom_ir_pronto_data).state;

          // Normalize whitespace + trim (same rules as worker)
          std::string cleaned;
          cleaned.reserve(raw.size());
          bool last_space = true;
          for (char c : raw) {
            if (c == '\r' || c == '\n' || c == '\t') c = ' ';
            if (c == ' ') {
              if (!last_space) cleaned.push_back(' ');
              last_space = true;
            } else {
              cleaned.push_back(c);
              last_space = false;
            }
          }
          while (!cleaned.empty() && cleaned.back() == ' ') cleaned.pop_back();
          size_t start = 0;
          while (start < cleaned.size() && cleaned[start] == ' ') start++;
          if (start > 0) cleaned.erase(0, start);

          if (cleaned.empty()) {
            id(atom_ir_last_error).publish_state("Pronto data empty");
            ESP_LOGE("ir", "Pronto not queued: data empty");
            return;
          }
          if (cleaned.size() > 1024) {
            char buf[120];
            snprintf(buf, sizeof(buf), "Pronto too long (len=%u)", (unsigned) cleaned.size());
            id(atom_ir_last_error).publish_state(buf);
            ESP_LOGE("ir", "%s", buf);
            return;
          }

          float f_rep = id(atom_ir_pronto_repeats).state;
          if (f_rep != f_rep) f_rep = 1.0f;  // NaN guard
          int rep = (int) (f_rep + 0.5f);
          if (rep < 1) rep = 1;
          if (rep > 10) rep = 10;

          if (id(ir_queue).size() >= IR_QUEUE_MAX) {
            id(atom_ir_last_error).publish_state("IR queue full");
            ESP_LOGW("ir", "Pronto not queued: queue full (%u/%u)", (unsigned) id(ir_queue).size(), (unsigned) IR_QUEUE_MAX);
            return;
          }

          std::string task = "P|" + std::to_string(rep) + "|" + cleaned;
          id(ir_queue).push_back(task);

          char msg[140];
          snprintf(msg, sizeof(msg), "QUEUED PRONTO len=%u rep=%d q=%u",
                   (unsigned) cleaned.size(), rep, (unsigned) id(ir_queue).size());
          id(atom_ir_last_tx).publish_state(msg);
          id(atom_ir_last_error).publish_state("");
          ESP_LOGI("ir", "%s", msg);
      - script.execute: ir_process_queue

  - platform: template
    name: "Atom Lite IR Cancel Queue"
    entity_category: diagnostic
    disabled_by_default: true
    on_press:
      - lambda: |-
          id(ir_queue).clear();
          id(atom_ir_last_error).publish_state("IR queue canceled by user");
      - logger.log:
          level: WARN
          format: "IR queue cleared by user"

  # Emergency recovery: clears queue + forces busy false (can desync if mid-transmit)
  - platform: template
    name: "Atom Lite IR Clear Busy"
    entity_category: diagnostic
    disabled_by_default: true
    on_press:
      - lambda: |-
          id(ir_queue).clear();
          id(ir_busy) = false;  // FORCE: use only for recovery
          id(atom_ir_last_error).publish_state("IR busy FORCE-cleared (recovery)");
      - script.stop: ir_process_queue
      - logger.log:
          level: WARN
          format: "IR busy flag FORCE-cleared (queue cleared). Use only for recovery."

# Stateless button events for Home Assistant automations (no light coupling)
event:
  - platform: template
    name: "Atom Button Action"
    id: atom_button_action
    device_class: button
    event_types:
      - single_click
      - double_click
      - long_press

# On-board IR blaster (Atom Lite IR is on GPIO12)
# RMT memory on ESP32 is shared; explicitly allocate to avoid contention with the RGB LED.
remote_transmitter:
  id: atom_ir
  pin: ${pin_ir_tx}
  carrier_duty_percent: 50%
  rmt_symbols: 448
  on_complete:
    then:
      - lambda: 'id(ir_busy) = false;'

binary_sensor:
  - platform: status
    name: "Atom Lite Status"

  - platform: gpio
    pin:
      number: ${pin_button}
      mode: INPUT
      inverted: true
    name: "Atom Button"
    id: atom_button
    filters:
      - delayed_on: 50ms
      - delayed_off: 50ms
    on_multi_click:
      - timing:
          - ON for at most 0.8s
          - OFF for at most 0.5s
          - ON for at most 0.8s
          - OFF for at least 0.2s
        then:
          - logger.log: "Double Clicked"
          - event.trigger:
              id: atom_button_action
              event_type: double_click

      - timing:
          - ON for at least 0.8s
        then:
          - logger.log: "Long Press"
          - event.trigger:
              id: atom_button_action
              event_type: long_press

      - timing:
          - ON for at most 0.8s
          - OFF for at least 0.2s
        then:
          - logger.log: "Single Click"
          - event.trigger:
              id: atom_button_action
              event_type: single_click

  # Optional: true when transmitting OR queued work exists
  - platform: template
    name: "Atom Lite IR Busy State"
    id: atom_ir_busy_state
    lambda: |-
      return id(ir_busy) || !id(ir_queue).empty();
    entity_category: diagnostic
    disabled_by_default: true

light:
  - platform: esp32_rmt_led_strip
    name: "Atom RGB Light"
    id: atom_light
    pin: ${pin_rgb}
    num_leds: 1
    rgb_order: GRB
    chipset: SK6812
    restore_mode: RESTORE_DEFAULT_OFF
    # Keep LED RMT footprint minimal; reserve RMT capacity for IR (especially long Pronto).
    rmt_symbols: 64
    max_refresh_rate: 20ms
    use_psram: false
    effects:
      - random:
          name: "Random"
          transition_length: 1s
          update_interval: 1s

debug:
  update_interval: 30s

sensor:
  - platform: uptime
    name: "Atom Lite Uptime"
    entity_category: diagnostic
    disabled_by_default: true

  - platform: wifi_signal
    name: "Atom Lite WiFi RSSI"
    update_interval: 60s
    entity_category: diagnostic

  - platform: internal_temperature
    name: "Atom Lite Internal Temperature"
    update_interval: 30s
    entity_category: diagnostic
    disabled_by_default: true

  # Numeric busy (0/1) kept for compatibility; includes queued work
  - platform: template
    name: "Atom Lite IR Busy"
    id: atom_ir_busy
    lambda: |-
      return (id(ir_busy) || !id(ir_queue).empty()) ? 1.0f : 0.0f;
    update_interval: 500ms
    accuracy_decimals: 0
    unit_of_measurement: ""
    entity_category: diagnostic
    disabled_by_default: true

  - platform: template
    name: "Atom Lite IR Queue Depth"
    id: atom_ir_queue_depth
    lambda: |-
      return (float) id(ir_queue).size();
    update_interval: 500ms
    accuracy_decimals: 0
    entity_category: diagnostic
    disabled_by_default: true

  - platform: debug
    free:
      name: "Atom Lite Heap Free"
      entity_category: diagnostic
      disabled_by_default: true
    block:
      name: "Atom Lite Heap Max Block"
      entity_category: diagnostic
      disabled_by_default: true
    loop_time:
      name: "Atom Lite Loop Time"
      entity_category: diagnostic
      disabled_by_default: true
    cpu_frequency:
      name: "Atom Lite CPU Frequency"
      entity_category: diagnostic
      disabled_by_default: true

text_sensor:
  - platform: version
    name: "Atom Lite ESPHome Version"
    hide_timestamp: true
    entity_category: diagnostic
    disabled_by_default: true

  - platform: template
    name: "Atom Lite IR Last TX"
    id: atom_ir_last_tx
    entity_category: diagnostic
    disabled_by_default: true

  - platform: template
    name: "Atom Lite IR Last Error"
    id: atom_ir_last_error
    entity_category: diagnostic
    disabled_by_default: true

  - platform: debug
    device:
      name: "Atom Lite Device Info"
      entity_category: diagnostic
      disabled_by_default: true
    reset_reason:
      name: "Atom Lite Reset Reason"
      entity_category: diagnostic
      disabled_by_default: true

  - platform: wifi_info
    ip_address:
      name: "Atom Lite IP"
      entity_category: diagnostic
    ssid:
      name: "Atom Lite SSID"
      entity_category: diagnostic
      disabled_by_default: true
    bssid:
      name: "Atom Lite BSSID"
      entity_category: diagnostic
      disabled_by_default: true
    mac_address:
      name: "Atom Lite MAC"
      entity_category: diagnostic
      disabled_by_default: true
    dns_address:
      name: "Atom Lite DNS"
      entity_category: diagnostic
      disabled_by_default: true
    power_save_mode:
      name: "Atom Lite WiFi Power Save"
      entity_category: diagnostic
      disabled_by_default: true
