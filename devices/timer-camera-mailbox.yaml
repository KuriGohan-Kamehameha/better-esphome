substitutions:
  device_id: timer-camera-f
  device_label: Timer Cam F
  led_label: LED
  tz: America/Toronto

esphome:
  name: ${device_id}
  friendly_name: ${device_label}
  on_boot:
    - priority: -100
      then:
        - script.execute: run_cycle

esp32:
  board: esp32dev
  framework:
    type: esp-idf

# PSRAM required for camera
psram:
  mode: quad
  speed: 80MHz

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  power_save_mode: none
  enable_on_boot: false
  reboot_timeout: 0s
  ap:
    ssid: "TimerCamera-F Fallback"
    password: "HZruGeKzRAfh"

logger:

api:
  reboot_timeout: 0s
  encryption:
    key: "7JFTWl/7SOz11JinNgajCK88Lu05aTew2D60iRoxpAQ="

ota:
  platform: esphome
  password: "b05ede71a13e4841f6805539b579fdfe"

captive_portal:

# I2C buses (RTC + camera SCCB)
i2c:
  - id: bsp_i2c
    sda: GPIO12
    scl: GPIO14
  - id: cam_i2c
    sda: GPIO25
    scl: GPIO23

time:
  - platform: bm8563
    id: rtc_time
    i2c_id: bsp_i2c
    timezone: ${tz}
    update_interval: never

  - platform: homeassistant
    id: ha_time
    timezone: ${tz}
    on_time_sync:
      then:
        - bm8563.write_time:
            id: rtc_time

# Camera (internal; no HA camera entity, prevents HA from pulling frames)
esp32_camera:
  id: cam
  external_clock:
    pin: GPIO27
    frequency: 20MHz
  i2c_id: cam_i2c
  data_pins: [GPIO32, GPIO35, GPIO34, GPIO5, GPIO39, GPIO18, GPIO36, GPIO19]
  vsync_pin: GPIO22
  href_pin: GPIO26
  pixel_clock_pin: GPIO21
  reset_pin: GPIO15

  vertical_flip: false
  horizontal_mirror: false

  # Full-res (OV3660 max)
  resolution: 2048x1536
  jpeg_quality: 10

  # Critical: stop background/idle captures
  idle_framerate: 0.0 fps

  on_image:
    then:
      - lambda: |-
          id(last_jpeg).assign((const char*) image.data, image.length);
          id(last_jpeg_len) = (uint32_t) image.length;
          id(image_ready) = true;

http_request:
  id: http_client
  useragent: "esphome/${device_id}"
  timeout: 15s

# Status LED (blue on-board, GPIO2)
output:
  - platform: ledc
    id: blue_led
    pin: GPIO2
    channel: 2  # camera uses LEDC timer #1; pin LEDC must specify a safe channel
  # Battery hold pin - MUST be HIGH for charging to work
  - platform: gpio
    id: batt_hold_pin
    pin: GPIO33

light:
  - platform: monochromatic
    output: blue_led
    name: "${led_label}"
    restore_mode: ALWAYS_OFF

# Enable battery charging by holding GPIO33 HIGH
switch:
  - platform: output
    id: battery_hold
    internal: true
    output: batt_hold_pin
    restore_mode: ALWAYS_ON

sensor:
  - platform: adc
    pin: GPIO38
    attenuation: 12dB
    id: battery_voltage
    internal: true
    update_interval: 300s
    filters:
      - multiply: 1.51

  - platform: template
    id: battery_percent
    name: "Battery %"
    unit_of_measurement: "%"
    device_class: battery
    accuracy_decimals: 0
    update_interval: 300s
    lambda: |-
      float v = id(battery_voltage).state;
      if (v <= 3.35f) return 0.0f;
      if (v >= 4.15f) return 100.0f;
      return (v - 3.35f) / 0.80f * 100.0f;

# Limit switch on Grove SCL (GPIO13) -> wake + state
binary_sensor:
  - platform: gpio
    id: mailbox_switch
    internal: true
    pin:
      number: GPIO13
      mode: INPUT_PULLUP
      inverted: true
      allow_other_uses: true
    filters:
      - delayed_on: 15ms
      - delayed_off: 15ms

deep_sleep:
  id: deep_sleep_ctrl
  wakeup_pin:
    number: GPIO13
    mode: INPUT_PULLUP
    inverted: true
    allow_other_uses: true
  wakeup_pin_mode: KEEP_AWAKE

globals:
  - id: image_ready
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: capture_ok
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: last_jpeg
    type: std::string
    restore_value: no
    initial_value: '""'
  - id: last_jpeg_len
    type: uint32_t
    restore_value: no
    initial_value: '0'
  - id: upload_done
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: upload_status
    type: int
    restore_value: no
    initial_value: '-999'

script:
  - id: run_cycle
    mode: single
    then:
      # Guarantee WiFi is OFF during capture
      - wifi.disable

      # Pull time from RTC immediately (so "until noon" works even before WiFi)
      - bm8563.read_time:
          id: rtc_time

      # Get a fresh battery reading before deciding JPEG quality
      - component.update: battery_voltage
      - delay: 50ms

      # Skip EXT0 "release" wakes: woke from GPIO13, but switch isn't active anymore
      - if:
          condition:
            lambda: |-
              return (esp_sleep_get_wakeup_cause() == ESP_SLEEP_WAKEUP_EXT0) && (!id(mailbox_switch).state);
          then:
            - logger.log: "Wake: switch release; skipping capture/upload."
          else:
            - script.execute: capture_upload

      - script.execute: sync_and_sleep

  - id: capture_upload
    mode: single
    then:
      - lambda: |-
          id(image_ready) = false;
          id(capture_ok) = false;
          id(last_jpeg).clear();
          id(last_jpeg_len) = 0;

      # Brownout avoidance: keep full-res, but relax JPEG quality when pack is low.
      - lambda: |-
          float v = id(battery_voltage).state;
          // If ADC isn't ready yet, assume "not low" to avoid overreacting.
          if (v < 1.0f || v > 5.0f) v = 4.2f;

          uint8_t q = 10;  // best
          if (v < 3.55f) q = 40;       // much lighter encode/load
          else if (v < 3.70f) q = 25;  // moderate

          id(cam).set_jpeg_quality(q);
          id(cam).update_camera_parameters();
          ESP_LOGI("cam", "V=%.2fV jpeg_quality=%u", v, q);

      # Capture (WiFi still OFF)
      - lambda: |-
          id(cam).request_image(esphome::camera::API_REQUESTER);

      - wait_until:
          condition:
            lambda: 'return id(image_ready);'
          timeout: 6s

      - if:
          condition:
            lambda: 'return id(image_ready) && (id(last_jpeg_len) > 1024);'
          then:
            - lambda: |-
                id(capture_ok) = true;
                ESP_LOGI("cam", "Captured %u bytes", id(last_jpeg_len));
          else:
            - logger.log: "Capture failed (timeout or tiny frame)."

      # Upload (WiFi ON only here)
      - if:
          condition:
            lambda: 'return id(capture_ok);'
          then:
            - wifi.enable
            - wait_until:
                condition:
                  wifi.connected:
                timeout: 20s

            - if:
                condition:
                  wifi.connected:
                then:
                  - lambda: |-
                      id(upload_done) = false;
                      id(upload_status) = -999;

                  - http_request.send:
                      method: POST
                      url: !secret mailbox_upload_url
                      request_headers:
                        Content-Type: image/jpeg
                        X-ESPHome-Node: ${device_id}
                      body: !lambda |-
                        return id(last_jpeg);
                      on_response:
                        then:
                          - lambda: |-
                              id(upload_done) = true;
                              id(upload_status) = response->status_code;
                              ESP_LOGI("upload", "HTTP %d (%u ms)", response->status_code, response->duration_ms);

                  - wait_until:
                      condition:
                        lambda: 'return id(upload_done);'
                      timeout: 20s

                  - if:
                      condition:
                        lambda: 'return id(upload_done) && (id(upload_status) >= 200) && (id(upload_status) < 300);'
                      then:
                        - logger.log: "Upload OK."
                      else:
                        - lambda: |-
                            ESP_LOGW("upload", "Upload done=%s status=%d",
                                     id(upload_done) ? "true" : "false",
                                     id(upload_status));
                else:
                  - logger.log: "WiFi connect failed; skipping upload."

  - id: sync_and_sleep
    mode: single
    then:
      # If WiFi is up, give HA time a chance to sync, then write RTC right before sleep.
      - if:
          condition:
            wifi.connected:
          then:
            - wait_until:
                condition:
                  lambda: 'return id(ha_time).now().is_valid();'
                timeout: 10s

      - if:
          condition:
            lambda: 'return id(ha_time).now().is_valid();'
          then:
            - bm8563.write_time:
                id: rtc_time

      # Kill WiFi before sleep (and before next capture cycle)
      - wifi.disable
      - delay: 200ms

      # Sleep until next *local* noon (Toronto), but still wake on the switch.
      - if:
          condition:
            lambda: 'return id(ha_time).now().is_valid();'
          then:
            - deep_sleep.enter:
                id: deep_sleep_ctrl
                until: "12:00:00"
                time_id: ha_time
          else:
            - deep_sleep.enter:
                id: deep_sleep_ctrl
                until: "12:00:00"
                time_id: rtc_time
