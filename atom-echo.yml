substitutions:
  name: atom-echo
  friendly_name: Atom Echo
  # Pin map (M5Stack Atom Echo)
  pin_button: GPIO39
  pin_led: GPIO27
  pin_i2s_lrclk: GPIO33
  pin_i2s_bclk: GPIO19
  pin_i2s_din: GPIO23
  pin_i2s_dout: GPIO22
  # Audio defaults
  audio_sample_rate: "16000"
  speaker_bits_per_sample: 16bit
  speaker_buffer_duration: 60ms

esphome:
  name: ${name}
  name_add_mac_suffix: false
  friendly_name: ${friendly_name}
  min_version: 2025.5.0
  # Defensive: avoids some ESP32 flash-mode edge cases on certain modules.
  platformio_options:
    board_build.flash_mode: dio
  on_boot:
    priority: -100
    then:
      - script.execute: sync_color_editor

esp32:
  board: m5stack-atom
  cpu_frequency: 240MHz
  framework:
    type: esp-idf

logger:
  level: INFO
  baud_rate: 115200

safe_mode:
  boot_is_good_after: 1min
  num_attempts: 10
  reboot_timeout: 5min

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  fast_connect: true
  power_save_mode: none
  ap:
    ssid: "${friendly_name} Fallback"
    password: "12345678"

api:
  reboot_timeout: 0s
  encryption:
    key: FZD1Uawj+EJum/aIzFxa/VkHF11ehVT6uP2Gv2FB4lw=

ota:
  - platform: esphome
    id: ota_esphome
    password: "bd0c8d0f698358a6436ba3134414e856"

captive_portal:

globals:
  - id: va_phase
    type: int
    restore_value: no
    initial_value: "0"
  # Stored color settings (0.0-1.0)
  - id: listen_light_color_r
    type: float
    restore_value: true
    initial_value: "1.0"
  - id: listen_light_color_g
    type: float
    restore_value: true
    initial_value: "0.89"
  - id: listen_light_color_b
    type: float
    restore_value: true
    initial_value: "0.71"
  - id: listening_light_color_r
    type: float
    restore_value: true
    initial_value: "0.0"
  - id: listening_light_color_g
    type: float
    restore_value: true
    initial_value: "0.0"
  - id: listening_light_color_b
    type: float
    restore_value: true
    initial_value: "1.0"
  - id: processing_light_color_r
    type: float
    restore_value: true
    initial_value: "0.0"
  - id: processing_light_color_g
    type: float
    restore_value: true
    initial_value: "0.0"
  - id: processing_light_color_b
    type: float
    restore_value: true
    initial_value: "1.0"
  - id: speaking_light_color_r
    type: float
    restore_value: true
    initial_value: "0.0"
  - id: speaking_light_color_g
    type: float
    restore_value: true
    initial_value: "0.0"
  - id: speaking_light_color_b
    type: float
    restore_value: true
    initial_value: "1.0"

button:
  - platform: restart
    id: restart_btn
    name: "${friendly_name} Restart"
    entity_category: config

  - platform: safe_mode
    id: safe_mode_btn
    name: "${friendly_name} Restart (Safe Mode)"
    entity_category: config

  - platform: factory_reset
    id: factory_reset_btn
    name: "${friendly_name} Factory reset"
    entity_category: config

i2s_audio:
  - id: i2s_audio_bus
    i2s_lrclk_pin: ${pin_i2s_lrclk}
    i2s_bclk_pin: ${pin_i2s_bclk}

microphone:
  - platform: i2s_audio
    id: echo_microphone
    i2s_audio_id: i2s_audio_bus
    i2s_din_pin: ${pin_i2s_din}
    adc_type: external
    pdm: true
    sample_rate: ${audio_sample_rate}
    correct_dc_offset: true

speaker:
  - platform: i2s_audio
    id: echo_speaker
    i2s_audio_id: i2s_audio_bus
    i2s_dout_pin: ${pin_i2s_dout}
    dac_type: external
    bits_per_sample: ${speaker_bits_per_sample}
    sample_rate: ${audio_sample_rate}
    channel: stereo
    buffer_duration: ${speaker_buffer_duration}

media_player:
  - platform: speaker
    id: echo_media_player
    name: ""
    internal: true
    announcement_pipeline:
      speaker: echo_speaker
      format: WAV
    codec_support_enabled: true
    buffer_size: 6000
    volume_min: 0.4
    files:
      - id: timer_finished_wave_file
        file: https://github.com/esphome/wake-word-voice-assistants/raw/main/sounds/timer_finished.wav

    on_announcement:
      - if:
          condition:
            - microphone.is_capturing:
          then:
            - script.execute: stop_wake_word
      # Don't clobber the timer alarm LED pattern.
      - if:
          condition:
            - switch.is_off: timer_ringing
          then:
            - script.execute: led_speaking

    on_idle:
      - lambda: |-
          id(va_phase) = 0;
      - script.execute: start_wake_word
      - script.execute: reset_led

voice_assistant:
  id: va
  microphone:
    microphone: echo_microphone
    channels: 0
    gain_factor: 4
  media_player: echo_media_player
  noise_suppression_level: 2
  auto_gain: 31dBFS

  on_listening:
    - lambda: |-
        id(va_phase) = 1;
    - script.execute: led_listening

  on_stt_vad_end:
    - lambda: |-
        id(va_phase) = 2;
    - script.execute: led_processing

  on_tts_start:
    - lambda: |-
        id(va_phase) = 3;
    - script.execute: led_speaking

  on_end:
    - lambda: |-
        id(va_phase) = 0;
    - wait_until:
        condition:
          - media_player.is_announcing:
              id: echo_media_player
        timeout: 0.5s
    - if:
        condition:
          - lambda: |-
              return id(wake_word_engine_location).current_option() == "On device";
        then:
          - wait_until:
              condition:
                - and:
                    - not: voice_assistant.is_running
                    - not: speaker.is_playing
              timeout: 2s
          - if:
              condition:
                - switch.is_off: mute_mic
              then:
                - lambda: id(va).set_use_wake_word(false);
                - micro_wake_word.start
    - script.execute: reset_led

  on_error:
    - lambda: |-
        id(va_phase) = 0;
    - script.execute: led_error
    - delay: 2s
    - script.execute: reset_led

  on_client_connected:
    - delay: 2s
    - script.execute: start_wake_word

  on_client_disconnected:
    - lambda: |-
        id(va_phase) = 0;
    - script.execute: stop_wake_word

  on_timer_finished:
    - script.execute: stop_wake_word
    - wait_until:
        condition:
          - not: microphone.is_capturing
        timeout: 2s
    - switch.turn_on: timer_ringing
    - light.turn_on:
        id: led
        red: 0%
        green: 100%
        blue: 0%
        brightness: 100%
        effect: "Fast Pulse"
    - wait_until:
        condition:
          - switch.is_off: timer_ringing
        timeout: 16min
    - light.turn_off: led
    - switch.turn_off: timer_ringing

binary_sensor:
  - platform: gpio
    pin:
      number: ${pin_button}
      inverted: true
    name: Button
    disabled_by_default: true
    entity_category: diagnostic
    id: echo_button
    on_multi_click:
      - timing:
          - ON for at least 3s
          - OFF for at least 50ms
        then:
          - switch.toggle: mute_mic

      - timing:
          - ON for at least 10s
        then:
          - button.press: factory_reset_btn

      - timing:
          - ON for at least 50ms
          - OFF for at least 50ms
        then:
          - if:
              condition:
                switch.is_on: timer_ringing
              then:
                - switch.turn_off: timer_ringing
              else:
                - if:
                    condition:
                      - switch.is_off: mute_mic
                    then:
                      - voice_assistant.start
                    else:
                      - script.execute: reset_led

output:
  - platform: template
    id: va_color_editor_r_out
    type: float
    write_action:
      - lambda: |-
          return;
  - platform: template
    id: va_color_editor_g_out
    type: float
    write_action:
      - lambda: |-
          return;
  - platform: template
    id: va_color_editor_b_out
    type: float
    write_action:
      - lambda: |-
          return;

light:
  - platform: esp32_rmt_led_strip
    id: led
    name: ""
    internal: true
    pin: ${pin_led}
    default_transition_length: 0s
    chipset: SK6812
    num_leds: 1
    rgb_order: grb
    effects:
      - pulse:
          name: "Slow Pulse"
          transition_length: 250ms
          update_interval: 250ms
          min_brightness: 50%
          max_brightness: 100%
      - pulse:
          name: "Fast Pulse"
          transition_length: 100ms
          update_interval: 100ms
          min_brightness: 50%
          max_brightness: 100%
  - platform: rgb
    name: VA light color
    id: va_color_editor
    entity_category: config
    icon: mdi:palette
    restore_mode: RESTORE_DEFAULT_ON
    default_transition_length: 0s
    red: va_color_editor_r_out
    green: va_color_editor_g_out
    blue: va_color_editor_b_out
    on_state:
      then:
        - lambda: |-
            auto values = id(va_color_editor).current_values;
            if (!values.get_state()) {
              return;
            }
            const auto target = id(va_color_target).current_option();
            if (target == "Listen") {
              id(listen_light_color_r) = values.get_red();
              id(listen_light_color_g) = values.get_green();
              id(listen_light_color_b) = values.get_blue();
            } else if (target == "Listening") {
              id(listening_light_color_r) = values.get_red();
              id(listening_light_color_g) = values.get_green();
              id(listening_light_color_b) = values.get_blue();
            } else if (target == "Processing") {
              id(processing_light_color_r) = values.get_red();
              id(processing_light_color_g) = values.get_green();
              id(processing_light_color_b) = values.get_blue();
            } else if (target == "Speaking") {
              id(speaking_light_color_r) = values.get_red();
              id(speaking_light_color_g) = values.get_green();
              id(speaking_light_color_b) = values.get_blue();
            } else {
              id(listen_light_color_r) = values.get_red();
              id(listen_light_color_g) = values.get_green();
              id(listen_light_color_b) = values.get_blue();
            }
        - if:
            condition:
              - and:
                  - lambda: |-
                      return id(va_color_target).current_option() == "Listen";
                  - switch.is_on: use_listen_light
                  - not: voice_assistant.is_running
                  - not: speaker.is_playing
            then:
              - script.execute: reset_led
        - if:
            condition:
              - and:
                  - lambda: |-
                      return id(va_color_target).current_option() == "Listening";
                  - voice_assistant.is_running
                  - lambda: |-
                      return id(va_phase) == 1;
            then:
              - script.execute: led_listening
        - if:
            condition:
              - and:
                  - lambda: |-
                      return id(va_color_target).current_option() == "Processing";
                  - voice_assistant.is_running
                  - lambda: |-
                      return id(va_phase) == 2;
            then:
              - script.execute: led_processing
        - if:
            condition:
              - and:
                  - lambda: |-
                      return id(va_color_target).current_option() == "Speaking";
                  - voice_assistant.is_running
                  - lambda: |-
                      return id(va_phase) == 3;
            then:
              - script.execute: led_speaking

number:
  # ---- Speaker volume ----
  - platform: template
    name: Volume
    id: volume_slider
    entity_category: config
    unit_of_measurement: "%"
    icon: mdi:volume-high
    mode: slider
    min_value: 40
    max_value: 100
    step: 1
    optimistic: true
    restore_value: true
    initial_value: 60
    on_value:
      - media_player.volume_set:
          id: echo_media_player
          volume: !lambda return x / 100.0f;

  # ---- Idle "listen light" (only used when Use listen light is ON and wake word is On device) ----
  - platform: template
    name: Listen light brightness
    id: listen_light_brightness
    entity_category: config
    unit_of_measurement: "%"
    mode: slider
    min_value: 0
    max_value: 100
    step: 1
    optimistic: true
    restore_value: true
    initial_value: 60
    on_value:
      then:
        - if:
            condition:
              - and:
                  - switch.is_on: use_listen_light
                  - not: voice_assistant.is_running
                  - not: speaker.is_playing
            then:
              - script.execute: reset_led

  # ---- Listening (wake word accepted, user speaking) ----
  - platform: template
    name: Listening light brightness
    id: listening_light_brightness
    entity_category: config
    unit_of_measurement: "%"
    mode: slider
    min_value: 0
    max_value: 100
    step: 1
    optimistic: true
    restore_value: true
    initial_value: 100
    on_value:
      then:
        - if:
            condition:
              - and:
                  - voice_assistant.is_running
                  - lambda: |-
                      return id(va_phase) == 1;
            then:
              - script.execute: led_listening

  # ---- Processing (STT ended, thinking) ----
  - platform: template
    name: Processing light brightness
    id: processing_light_brightness
    entity_category: config
    unit_of_measurement: "%"
    mode: slider
    min_value: 0
    max_value: 100
    step: 1
    optimistic: true
    restore_value: true
    initial_value: 100
    on_value:
      then:
        - if:
            condition:
              - and:
                  - voice_assistant.is_running
                  - lambda: |-
                      return id(va_phase) == 2;
            then:
              - script.execute: led_processing

  # ---- Speaking (TTS/announcement playback) ----
  - platform: template
    name: Speaking light brightness
    id: speaking_light_brightness
    entity_category: config
    unit_of_measurement: "%"
    mode: slider
    min_value: 0
    max_value: 100
    step: 1
    optimistic: true
    restore_value: true
    initial_value: 100
    on_value:
      then:
        - if:
            condition:
              - and:
                  - voice_assistant.is_running
                  - lambda: |-
                      return id(va_phase) == 3;
            then:
              - script.execute: led_speaking

script:
  - id: sync_color_editor
    mode: restart
    then:
      - light.turn_on:
          id: va_color_editor
          red: !lambda |-
            const auto target = id(va_color_target).current_option();
            if (target == "Listening") return id(listening_light_color_r);
            if (target == "Processing") return id(processing_light_color_r);
            if (target == "Speaking") return id(speaking_light_color_r);
            return id(listen_light_color_r);
          green: !lambda |-
            const auto target = id(va_color_target).current_option();
            if (target == "Listening") return id(listening_light_color_g);
            if (target == "Processing") return id(processing_light_color_g);
            if (target == "Speaking") return id(speaking_light_color_g);
            return id(listen_light_color_g);
          blue: !lambda |-
            const auto target = id(va_color_target).current_option();
            if (target == "Listening") return id(listening_light_color_b);
            if (target == "Processing") return id(processing_light_color_b);
            if (target == "Speaking") return id(speaking_light_color_b);
            return id(listen_light_color_b);
  - id: led_muted
    mode: restart
    then:
      - light.turn_on:
          id: led
          red: 100%
          green: 0%
          blue: 0%
          brightness: 40%
          effect: none

  - id: led_error
    mode: restart
    then:
      - light.turn_on:
          id: led
          red: 100%
          green: 0%
          blue: 0%
          brightness: 100%
          effect: none

  - id: led_idle
    mode: restart
    then:
      - light.turn_on:
          id: led
          red: !lambda |-
            float v = id(listen_light_color_r);
            return std::clamp(isnan(v) ? 1.0f : v, 0.0f, 1.0f);
          green: !lambda |-
            float v = id(listen_light_color_g);
            return std::clamp(isnan(v) ? 0.89f : v, 0.0f, 1.0f);
          blue: !lambda |-
            float v = id(listen_light_color_b);
            return std::clamp(isnan(v) ? 0.71f : v, 0.0f, 1.0f);
          brightness: !lambda |-
            float v = id(listen_light_brightness).state;
            return std::clamp(isnan(v) ? 60.0f : v, 0.0f, 100.0f) / 100.0f;
          effect: none

  - id: led_listening
    mode: restart
    then:
      - light.turn_on:
          id: led
          red: !lambda |-
            return std::clamp(isnan(id(listening_light_color_r)) ? 0.0f : id(listening_light_color_r), 0.0f, 1.0f);
          green: !lambda |-
            return std::clamp(isnan(id(listening_light_color_g)) ? 0.0f : id(listening_light_color_g), 0.0f, 1.0f);
          blue: !lambda |-
            return std::clamp(isnan(id(listening_light_color_b)) ? 1.0f : id(listening_light_color_b), 0.0f, 1.0f);
          brightness: !lambda |-
            return std::clamp(isnan(id(listening_light_brightness).state) ? 100.0f : id(listening_light_brightness).state, 0.0f, 100.0f) / 100.0f;
          effect: "Slow Pulse"

  - id: led_processing
    mode: restart
    then:
      - light.turn_on:
          id: led
          red: !lambda |-
            return std::clamp(isnan(id(processing_light_color_r)) ? 0.0f : id(processing_light_color_r), 0.0f, 1.0f);
          green: !lambda |-
            return std::clamp(isnan(id(processing_light_color_g)) ? 0.0f : id(processing_light_color_g), 0.0f, 1.0f);
          blue: !lambda |-
            return std::clamp(isnan(id(processing_light_color_b)) ? 1.0f : id(processing_light_color_b), 0.0f, 1.0f);
          brightness: !lambda |-
            return std::clamp(isnan(id(processing_light_brightness).state) ? 100.0f : id(processing_light_brightness).state, 0.0f, 100.0f) / 100.0f;
          effect: "Fast Pulse"

  - id: led_speaking
    mode: restart
    then:
      - light.turn_on:
          id: led
          red: !lambda |-
            return std::clamp(isnan(id(speaking_light_color_r)) ? 0.0f : id(speaking_light_color_r), 0.0f, 1.0f);
          green: !lambda |-
            return std::clamp(isnan(id(speaking_light_color_g)) ? 0.0f : id(speaking_light_color_g), 0.0f, 1.0f);
          blue: !lambda |-
            return std::clamp(isnan(id(speaking_light_color_b)) ? 1.0f : id(speaking_light_color_b), 0.0f, 1.0f);
          brightness: !lambda |-
            return std::clamp(isnan(id(speaking_light_brightness).state) ? 100.0f : id(speaking_light_brightness).state, 0.0f, 100.0f) / 100.0f;
          effect: none

  - id: reset_led
    mode: restart
    then:
      - if:
          condition:
            - switch.is_on: mute_mic
          then:
            - script.execute: led_muted
          else:
            - if:
                condition:
                  - and:
                      - switch.is_on: use_listen_light
                      - lambda: |-
                          return id(wake_word_engine_location).current_option() == "On device";
                then:
                  - script.execute: led_idle
                else:
                  - light.turn_off: led

  - id: start_wake_word
    mode: restart
    then:
      - if:
          condition:
            - switch.is_on: mute_mic
          then:
            - script.execute: reset_led
          else:
            - if:
                condition:
                  - and:
                      - not: voice_assistant.is_running
                      - lambda: |-
                          return id(wake_word_engine_location).current_option() == "On device";
                then:
                  - lambda: id(va).set_use_wake_word(false);
                  - micro_wake_word.start
            - if:
                condition:
                  - and:
                      - not: voice_assistant.is_running
                      - lambda: |-
                          return id(wake_word_engine_location).current_option() == "In Home Assistant";
                then:
                  - lambda: id(va).set_use_wake_word(true);
                  - voice_assistant.start_continuous
            - script.execute: reset_led

  - id: stop_wake_word
    mode: restart
    then:
      - lambda: |-
          id(va_phase) = 0;
      - if:
          condition:
            - lambda: |-
                return id(wake_word_engine_location).current_option() == "In Home Assistant";
          then:
            - lambda: id(va).set_use_wake_word(false);
            - voice_assistant.stop
      - if:
          condition:
            - lambda: |-
                return id(wake_word_engine_location).current_option() == "On device";
          then:
            - micro_wake_word.stop

switch:
  - platform: template
    name: Use listen light
    id: use_listen_light
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    entity_category: config
    on_turn_on:
      - script.execute: reset_led
    on_turn_off:
      - script.execute: reset_led

  - platform: template
    name: Mute mic
    id: mute_mic
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    entity_category: config
    on_turn_on:
      - script.execute: stop_wake_word
      - script.execute: reset_led
    on_turn_off:
      - script.execute: start_wake_word
      - script.execute: reset_led

  - platform: template
    id: timer_ringing
    optimistic: true
    restore_mode: ALWAYS_OFF
    on_turn_off:
      - lambda: |-
          id(echo_media_player)
            ->make_call()
            .set_command(media_player::MEDIA_PLAYER_COMMAND_REPEAT_OFF)
            .set_announcement(true)
            .perform();
          id(echo_media_player)->set_playlist_delay_ms(
            speaker::AudioPipelineType::ANNOUNCEMENT, 0);
      - media_player.stop:
          id: echo_media_player
          announcement: true
      - script.execute: reset_led
    on_turn_on:
      - lambda: |-
          id(echo_media_player)
            ->make_call()
            .set_command(media_player::MEDIA_PLAYER_COMMAND_REPEAT_ONE)
            .set_announcement(true)
            .perform();
          id(echo_media_player)->set_playlist_delay_ms(
            speaker::AudioPipelineType::ANNOUNCEMENT, 1000);
      - media_player.speaker.play_on_device_media_file:
          id: echo_media_player
          media_file: timer_finished_wave_file
          announcement: true
      - delay: 15min
      - switch.turn_off: timer_ringing

select:
  - platform: template
    entity_category: config
    name: VA light target
    id: va_color_target
    optimistic: true
    restore_value: true
    options:
      - Listen
      - Listening
      - Processing
      - Speaking
    initial_option: Listen
    on_value:
      - script.execute: sync_color_editor

  - platform: template
    entity_category: config
    name: Wake word engine location
    id: wake_word_engine_location
    optimistic: true
    restore_value: true
    options:
      - In Home Assistant
      - On device
    initial_option: On device
    on_value:
      - if:
          condition:
            - lambda: return x == "In Home Assistant";
          then:
            - micro_wake_word.stop
            - delay: 500ms
            - lambda: id(va).set_use_wake_word(true);
            - voice_assistant.start_continuous
      - if:
          condition:
            - lambda: return x == "On device";
          then:
            - lambda: id(va).set_use_wake_word(false);
            - voice_assistant.stop
            - delay: 500ms
            - if:
                condition:
                  - switch.is_off: mute_mic
                then:
                  - micro_wake_word.start
      - script.execute: reset_led

micro_wake_word:
  on_wake_word_detected:
    - if:
        condition:
          - switch.is_off: mute_mic
        then:
          - voice_assistant.start:
              wake_word: !lambda return wake_word;
  vad: {}
  models:
    - model: okay_nabu
    - model: hey_mycroft
    - model: hey_jarvis

