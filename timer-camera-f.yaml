substitutions:
  device_id: timer-camera-f
  device_label: Timer Cam F
  cam_label: Cam
  led_label: LED
  batt_v_label: Batt V
  batt_pct_label: Batt %

esphome:
  name: ${device_id}
  friendly_name: ${device_label}

  on_boot:
    priority: 600
    then:
      - bm8563.read_time: {}

esp32:
  board: esp32dev
  framework:
    type: esp-idf

# PSRAM required for camera
psram:
  mode: quad
  speed: 80MHz

# Networking + OTA + API
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "TimerCamera-F Fallback"
    password: "HZruGeKzRAfh"

logger:

api:
  encryption:
    key: "7JFTWl/7SOz11JinNgajCK88Lu05aTew2D60iRoxpAQ="

ota:
  platform: esphome
  password: "b05ede71a13e4841f6805539b579fdfe"

captive_portal:

# I2C buses (RTC + camera SCCB)
i2c:
  - id: bsp_i2c
    sda: GPIO12
    scl: GPIO14
  - id: cam_i2c
    sda: GPIO25
    scl: GPIO23

# Timer Cam F camera config
esp32_camera:
  name: "${cam_label}"
  external_clock:
    pin: GPIO27
    frequency: 20MHz
  i2c_id: cam_i2c
  data_pins: [GPIO32, GPIO35, GPIO34, GPIO5, GPIO39, GPIO18, GPIO36, GPIO19]
  vsync_pin: GPIO22
  href_pin: GPIO26
  pixel_clock_pin: GPIO21
  reset_pin: GPIO15
  resolution: 640x480
  jpeg_quality: 10
  max_framerate: 15 fps

# Optional local web server (stream + snapshot)
web_server:
  port: 80

# RTC to keep time
time:
  - platform: bm8563
    i2c_id: bsp_i2c
    id: rtc_time

# Status LED (blue on-board, GPIO2)
output:
  - platform: ledc
    id: blue_led
    pin: GPIO2

light:
  - platform: monochromatic
    output: blue_led
    name: "${led_label}"
    restore_mode: RESTORE_DEFAULT_ON

# Battery read and percentage
sensor:
  - platform: adc
    pin: GPIO38
    attenuation: 12dB
    id: battery_voltage
    name: "${batt_v_label}"
    update_interval: 30s
    filters:
      - multiply: 1.51

  - platform: template
    id: battery_percent
    name: "${batt_pct_label}"
    unit_of_measurement: "%"
    accuracy_decimals: 0
    lambda: |-
      float v = id(battery_voltage).state;
      const float min_v = 3.35;
      const float max_v = 4.15;
      if (v <= min_v) return 0.0;
      if (v >= max_v) return 100.0;
      return (v - min_v) / (max_v - min_v) * 100.0;
